import{_ as a,o as i,c as t,ag as n}from"./chunks/framework.uP9B3d38.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"leetcode-notes/03-binary-tree/binary-tree-operations.md","filePath":"leetcode-notes/03-binary-tree/binary-tree-operations.md","lastUpdated":1770569050000}'),e={name:"leetcode-notes/03-binary-tree/binary-tree-operations.md"};function p(l,s,r,h,o,k){return i(),t("div",null,[...s[0]||(s[0]=[n(`<p>前序遍历</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> preorderTraversal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: Optional[TreeNode]) -&gt; List[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root: Optional[TreeNode]):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">				return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			result.append(root.val)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			dfs(root.left)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			dfs(root.right)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		dfs(root)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result</span></span></code></pre></div><p>二叉树的最大深度</p><div class="language-python（分解问题） vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python（分解问题）</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>def maxDepth(self, root):</span></span>
<span class="line"><span>	if not root:</span></span>
<span class="line"><span>		return 0</span></span>
<span class="line"><span>	leftmax = self.maxDepth(root.left)</span></span>
<span class="line"><span>	rightmax = self.maxDepth(root.right)</span></span>
<span class="line"><span>	return 1 + max(leftmax, rightmax)</span></span></code></pre></div>`,4)])])}const c=a(e,[["render",p]]);export{E as __pageData,c as default};
